# 0 AIA, PLIC, CLINT

## 0-0 CLINT

CLINT: Core-Local INTerruptor，翻译成中文可以叫核局部中断器。它是Hart私有的，不处理来自外部设备的中断。

核心功能有二：

* 软件中断：一个Hart可以通过写CLINT的寄存器，来向自己或其他Hart触发一个中断。这主要用于处理器核之间的核间中断，实现多核间的通信和协同。
* 时钟中断：每个Hart都有一个定时器。CLINT包含一个公共的实时计数器mtime和每个Hart独有的比较寄存器mtimecmp。当mtime>mtimecmp时，就会向该Hart触发一个机器模式定时器中断。这是实现操作系统调度、超时等功能的基石。比如[rvos](https://6eanut.github.io/RISCV-LEARN/02_rvos/07_hwtimer/note/07_hwtimer.html)中的抢占式上下文切换就是通过hardware timer，借助软件中断实现的。

## 0-1 PLIC

PLIC: Platform Level Interrupt Controller，平台级中断控制器。它是整个系统全局共享的组件，所有外部IO设备的中断线都连接到PLIC，由PLIC统一管理并分发给各个Hart。

核心功能：

* 中断聚合与路由：系统可能有数十甚至上百个外部中断源，PLIC将它们收集起来；
* 优先级仲裁：为每个中断源配置优先级。当多个中断同时发生时，PLIC会选择优先级最高的那个；
* 目标分发：将仲裁胜出的中断，发送到一个或多个指定的Hart上，每个Hart可以独立启用或禁用特定的中断源；
* 中断处理：Hart收到中断后，会查询PLIC的寄存器，读取中断号，从而知道是哪个设备产生的中断，然后跳转到对应的驱动程序中处理。处理完成后，必须通知PLIC中断已处理，PLIC才会放下一个中断。

中断流程：

设备产生中断 -> PLIC接受并仲裁 -> PLIC通知目标Hart -> Hart进入中断处理程序 -> Hart查询PLIC -> PLIC返回中断号 -> Hart根据中断号执行设备驱动 -> 处理完毕，Hart通知PLIC完成 -> PLIC更新状态，准备下一次中断

## 0-2 AIA

AIA: Advanced Interrupt Architecture，高级中断架构。AIA不是一个单一的模块，而是一个套完整的规范体系。它旨在增强和补充RISC-V的中断系统，特别是为了支持现在高性能计算中常见的MSI中断模式，并统一中断控制器设置。

核心组成：

* APLIC: Advanced PLIC。是传统PLIC的增强版，一个关键的增强是APLIC除了支持传统的线基中断，还支持在根上下文中生成MSI。可以把APLIC看成能输出MSI的超级PLIC。
* IMSIC: Incoming MSI Controller。[MSI](MSI.md)接收控制器。这是AIA引入的核心组件。每个Hart都有一个自己的IMSIC。IMSIC时MSI中断的收件箱。它是一个内存映射的寄存器文件，当一个设备(APLIC)想要发送一个MSI时，它不是拉高一根物理线，而是向目标Hart的IMSIC的特定地址执行一次内存写操作，这次写的数据中就包含了中断号。

# 1 G-stage

G-stage是RISC-V虚拟机监控器中的翻译层，它将虚拟机看到的虚拟物理地址转换成真实的机器物理地址。

在没有虚拟化的普通系统中，地址翻译只有两级：

* S-stage：翻译的第一级。操作系统使用页表，将运行在S模式的应用程序看到的虚拟地址转换成物理地址；
* M-stage：翻译的最终级。硬件直接将物理地址映射到具体的机器物理地址(访问真实内存芯片的地址)。

当一个虚拟机监控器运行后，就多了一个G-stage。

# 2 NaCL嵌套虚拟

NaCL时一种利用内存加密和完整性保护技术实现的，以内存为中心的安全嵌套虚拟化方案。

* 目标：解决传统嵌套虚拟化的性能瓶颈，同时保证安全性；
* 核心机制：内存加密、完整性保护、安全所有权标签；
* 最大优点：将大部分嵌套虚拟化的性能路径从L2->L1->L0简化为L2->L0，允许L1在不威胁L2安全的前提下高效管理L2的普通资源。

传统方案，每次操作都要经过两层监控器，形成两次陷入，性能损失大，路径复杂：

* L2触发虚拟化异常->陷入到L1的监控器
* L1的监控器处理\->但自己也是虚拟机，需要在此触发异常
* L1的虚拟化异常->陷入到物理机L0的监控器
* L0的监控器模拟操作->返回结果给L1->L1再返回给L2

NaCL：

* L1向L0请求创建L2虚拟机
* L0为L2分配内存，并声称一个唯一的加密密钥。L2的物理内存用此密钥加密后交给L1管理
* L1可以完全控制L2的虚拟CPU状态、管理L2的页表，甚至可以看到L2的加密内存
* 但L1无法解密L2的内存，也无法在不被察觉的情况下篡改它
* 如果L2执行需要L0权限的操作，硬件不会陷入L1，而是直接进入L0
* 这是因为L1根本不具备处理这些操作的能力，L0接手处理，然后直接返回给L2
